name: Build Samsung A135F Kernel with SukiSU

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

env:
  KERNEL_NAME: a13x
  ARCH: arm64
  SUBARCH: arm64
  CONFIG: exynos850_defconfig
  TOOLCHAIN_VERSION: gcc-12
  JOBS: 4

jobs:
  build:
    runs-on: ubuntu-22.04
    
    steps:
    # Step 1: Checkout kernel source
    - name: Checkout Kernel Source
      uses: actions/checkout@v4
      with:
        path: kernel
        
    # Step 2: Check kernel version
    - name: Check Kernel Version
      id: check-kernel
      run: |
        cd kernel
        VERSION=$(grep '^VERSION =' Makefile | head -1 | awk '{print $3}')
        PATCHLEVEL=$(grep '^PATCHLEVEL =' Makefile | head -1 | awk '{print $3}')
        SUBLEVEL=$(grep '^SUBLEVEL =' Makefile | head -1 | awk '{print $3}')
        EXTRAVERSION=$(grep '^EXTRAVERSION =' Makefile | head -1 | awk '{print $3}')
        KERNEL_VERSION="${VERSION}.${PATCHLEVEL}.${SUBLEVEL}${EXTRAVERSION}"
        echo "Kernel Version: $KERNEL_VERSION"
        echo "version=$KERNEL_VERSION" >> $GITHUB_OUTPUT
        
    # Step 3: Setup environment
    - name: Setup Environment
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          git ccache build-essential zip curl \
          libssl-dev libelf-dev libncurses-dev \
          rsync cpio unzip kmod gcc make flex bison \
          python3 python3-pip bc lz4 lzop xxd wget \
          gcc-aarch64-linux-gnu gcc-arm-linux-gnueabi \
          clang-14 llvm-14 lld-14 \
          tree file
        
    # Step 4: Create fake toolchain structure
    - name: Create Fake Toolchain Structure
      run: |
        cd kernel
        
        echo "=== CREATING FAKE TOOLCHAIN STRUCTURE ==="
        
        # Create the exact directory structure Samsung kernel expects
        echo "1. Creating toolchain directory structure..."
        mkdir -p toolchain/clang/host/linux-x86/clang-r383902/bin
        
        echo "2. Creating symlinks to system clang-14..."
        ln -sf /usr/bin/clang-14 toolchain/clang/host/linux-x86/clang-r383902/bin/clang
        ln -sf /usr/bin/clang++-14 toolchain/clang/host/linux-x86/clang-r383902/bin/clang++
        ln -sf /usr/bin/ld.lld-14 toolchain/clang/host/linux-x86/clang-r383902/bin/ld.lld
        
        echo "3. Verifying symlinks..."
        ls -la toolchain/clang/host/linux-x86/clang-r383902/bin/
        
        echo "✅ Fake toolchain structure created"
        
    # Step 5: Fix script permissions
    - name: Fix All Script Permissions
      run: |
        cd kernel
        
        echo "=== FIXING ALL SCRIPT PERMISSIONS ==="
        
        echo "1. Making all *.sh files executable..."
        find . -name "*.sh" -type f -exec chmod +x {} \; 2>/dev/null || true
        
        echo "2. Making scripts directory fully executable..."
        chmod -R +x scripts/ 2>/dev/null || true
        
        echo "3. Fixing DOS line endings in critical scripts..."
        CRITICAL_SCRIPTS="
          scripts/clang-android.sh
          scripts/gcc-version.sh
          scripts/clang-version.sh
          scripts/lld-version.sh
          scripts/gcc-plugin.sh
        "
        
        for script in $CRITICAL_SCRIPTS; do
          if [ -f "$script" ]; then
            echo "  Fixing: $script"
            chmod +x "$script"
            sed -i 's/\r$//' "$script" 2>/dev/null
          fi
        done
        
        echo "✅ Script permissions fixed"
        
    # Step 6: Patch version detection scripts (FIXED YAML SYNTAX)
    - name: Patch Version Detection Scripts
      run: |
        cd kernel
        
        echo "=== PATCHING VERSION DETECTION SCRIPTS ==="
        
        # Create fixed versions of the scripts using printf
        echo "1. Creating fixed gcc-version.sh..."
        printf '#!/bin/bash\necho "110000"\nexit 0\n' > scripts/gcc-version.sh
        chmod +x scripts/gcc-version.sh
        
        echo "2. Creating fixed clang-version.sh..."
        printf '#!/bin/bash\necho "140000"\nexit 0\n' > scripts/clang-version.sh
        chmod +x scripts/clang-version.sh
        
        echo "3. Creating fixed lld-version.sh..."
        printf '#!/bin/bash\necho "140000"\nexit 0\n' > scripts/lld-version.sh
        chmod +x scripts/lld-version.sh
        
        echo "4. Creating fixed gcc-plugin.sh..."
        printf '#!/bin/bash\n# Dummy script to satisfy Kconfig\necho "gcc"\nexit 0\n' > scripts/gcc-plugin.sh
        chmod +x scripts/gcc-plugin.sh
        
        echo "✅ Version detection scripts fixed"
        
    # Step 7: Fix Kconfig syntax errors
    - name: Fix Kconfig Issues
      run: |
        cd kernel
        
        echo "=== FIXING KCONFIG ISSUES ==="
        
        echo "1. Creating a complete fixed init/Kconfig..."
        if [ -f "init/Kconfig" ]; then
          # Backup original
          cp init/Kconfig init/Kconfig.original
          
          # Replace the problematic config sections with simple defaults
          awk '
          /config CC_VERSION_TEXT/ {
            print "\tstring \"Compiler version\""
            print "\tdefault \"gcc (Ubuntu 11.4.0) 11.4.0\""
            getline; while ($0 ~ /^\t/) getline
            next
          }
          /config CLANG_VERSION_TEXT/ {
            print "\tstring \"Clang version\""
            print "\tdefault \"clang version 14.0.0\""
            getline; while ($0 ~ /^\t/) getline
            next
          }
          /config LD_VERSION_TEXT/ {
            print "\tstring \"LD version\""
            print "\tdefault \"LLD 14.0.0\""
            getline; while ($0 ~ /^\t/) getline
            next
          }
          { print }
          ' init/Kconfig.original > init/Kconfig
          
          echo "   init/Kconfig fixed"
        fi
        
        echo "2. Fixing GPU Kconfig conflicts..."
        # Fix MALI_ARBITRATION duplicate
        find drivers/gpu/arm -name "Kconfig" -type f | while read kconfig; do
          if grep -q "config MALI_ARBITRATION" "$kconfig"; then
            echo "  Fixing $kconfig"
            sed -i '/^config MALI_ARBITRATION$/d' "$kconfig"
            sed -i '/^config MALI_ARBITRATION[[:space:]]/d' "$kconfig"
          fi
        done
        
        echo "✅ Kconfig issues fixed"
        
    # Step 8: Install SukiSU
    - name: Install SukiSU (Built-in Branch)
      run: |
        cd kernel
        
        echo "=== INSTALLING SUKISU ==="
        
        # Clean any previous attempts
        rm -rf KernelSU SukiSU kernelsu 2>/dev/null || true
        
        echo "1. Running SukiSU setup script..."
        curl -LSs 'https://raw.githubusercontent.com/SukiSU-Ultra/SukiSU-Ultra/main/kernel/setup.sh' | bash -s builtin
        
        echo "2. Checking installation..."
        if [ -L "KernelSU" ] || [ -d "KernelSU" ]; then
          echo "✅ SukiSU installed successfully"
          ls -la | grep -i kernel
        else
          echo "⚠️ SukiSU setup may have failed"
          echo "Attempting manual installation..."
          git clone https://github.com/SukiSU-Ultra/SukiSU-Ultra.git --depth=1
          if [ -d "SukiSU-Ultra/kernel" ]; then
            ln -sf SukiSU-Ultra/kernel KernelSU
            echo "Manually created KernelSU symlink"
          fi
        fi
        
    # Step 9: Build configuration - FIXED APPROACH
    - name: Build Kernel Configuration
      run: |
        cd kernel
        
        echo "=== BUILDING KERNEL CONFIGURATION ==="
        
        export ARCH=arm64
        export SUBARCH=arm64
        export CROSS_COMPILE=aarch64-linux-gnu-
        export CROSS_COMPILE_ARM32=arm-linux-gnueabi-
        export HOSTCC=gcc
        export HOSTCXX=g++
        
        echo "1. Creating output directory..."
        mkdir -p out
        
        echo "2. Generating configuration using defconfig..."
        
        # First try to use the actual defconfig
        if [ -f "arch/arm64/configs/exynos850_defconfig" ]; then
          echo "Using exynos850_defconfig..."
          make O=out exynos850_defconfig 2>&1 | tee config.log || {
            echo "Defconfig failed, trying minimal config..."
            # Fallback to minimal config
            cat > out/.config << 'EOF'
CONFIG_SYSVIPC=y
CONFIG_POSIX_MQUEUE=y
CONFIG_AIO=y
CONFIG_ARM64=y
CONFIG_ARCH_EXYNOS=y
CONFIG_SOC_EXYNOS850=y
CONFIG_NR_CPUS=8
CONFIG_LOCALVERSION="-exynos850-a13x"
CONFIG_DEVTMPFS=y
CONFIG_DEVTMPFS_MOUNT=y
CONFIG_BLK_DEV=y
CONFIG_BLOCK=y
CONFIG_MODULES=y
CONFIG_MODULE_UNLOAD=y
CONFIG_KPROBES=y
CONFIG_HAVE_KPROBES=y
CONFIG_KPROBE_EVENTS=y
CONFIG_OVERLAY_FS=y
CONFIG_SUKISU=y
CONFIG_SUKISU_BUILTIN=y
EOF
          }
        else
          echo "Defconfig not found, using minimal config..."
          cat > out/.config << 'EOF'
CONFIG_SYSVIPC=y
CONFIG_POSIX_MQUEUE=y
CONFIG_AIO=y
CONFIG_ARM64=y
CONFIG_ARCH_EXYNOS=y
CONFIG_SOC_EXYNOS850=y
CONFIG_NR_CPUS=8
CONFIG_LOCALVERSION="-exynos850-a13x"
CONFIG_DEVTMPFS=y
CONFIG_DEVTMPFS_MOUNT=y
CONFIG_BLK_DEV=y
CONFIG_BLOCK=y
CONFIG_MODULES=y
CONFIG_MODULE_UNLOAD=y
CONFIG_KPROBES=y
CONFIG_HAVE_KPROBES=y
CONFIG_KPROBE_EVENTS=y
CONFIG_OVERLAY_FS=y
CONFIG_SUKISU=y
CONFIG_SUKISU_BUILTIN=y
EOF
        fi
        
        echo "3. Running olddefconfig to fill in defaults..."
        make O=out olddefconfig 2>&1 | tail -20 || {
          echo "olddefconfig failed, continuing with current config..."
        }
        
        echo "4. Checking SukiSU configuration..."
        if ! grep -q "CONFIG_SUKISU=y" out/.config; then
          echo "Adding SukiSU config..."
          echo "CONFIG_SUKISU=y" >> out/.config
          echo "CONFIG_SUKISU_BUILTIN=y" >> out/.config
          echo "CONFIG_KPROBES=y" >> out/.config
          echo "CONFIG_OVERLAY_FS=y" >> out/.config
        fi
        
        echo "5. Final configuration:"
        echo "Relevant configs:"
        grep -E "SUKISU|MODULES|KPROBES|OVERLAY|ARM64|EXYNOS" out/.config || echo "No configs found"
        
        echo "✅ Configuration complete"
        
    # Step 10: Build the kernel - FIXED BUILD COMMAND
    - name: Build Kernel
      run: |
        cd kernel
        
        echo "=== BUILDING KERNEL ==="
        
        export ARCH=arm64
        export SUBARCH=arm64
        export CROSS_COMPILE=aarch64-linux-gnu-
        export CROSS_COMPILE_ARM32=arm-linux-gnueabi-
        export HOSTCC=gcc
        export HOSTCXX=g++
        
        echo "1. Setting up environment..."
        echo "ARCH=$ARCH"
        echo "CROSS_COMPILE=$CROSS_COMPILE"
        echo "Using CC: $(which gcc)"
        echo "Using aarch64-linux-gnu-gcc: $(which aarch64-linux-gnu-gcc)"
        
        echo "2. Starting full kernel build (all targets)..."
        
        # Try building all targets instead of just Image
        # The error suggests the build is stopping early
        make -j${{ env.JOBS }} O=out all 2>&1 | tee build.log || {
          echo "=== BUILD FAILED - CHECKING ERRORS ==="
          echo "=== LAST 100 LINES OF BUILD LOG ==="
          tail -100 build.log
          echo "=== ERROR SUMMARY ==="
          grep -i "error:" build.log | head -20
          echo "=== WARNING SUMMARY ==="
          grep -i "warning:" build.log | head -20
          
          # Try alternative build approach
          echo "=== TRYING ALTERNATIVE BUILD ==="
          echo "Building vmlinux target only..."
          make -j1 O=out vmlinux 2>&1 | tee vmlinux.log
          
          if [ $? -eq 0 ]; then
            echo "vmlinux built successfully, now building Image..."
            make -j${{ env.JOBS }} O=out Image 2>&1 | tee image.log
          fi
        }
        
        echo "3. Checking build results..."
        BUILD_SUCCESS=false
        
        if [ -f "out/arch/arm64/boot/Image" ]; then
          echo "✅ Kernel Image built successfully!"
          file out/arch/arm64/boot/Image
          BUILD_SUCCESS=true
        elif [ -f "out/arch/arm64/boot/Image.gz" ]; then
          echo "✅ Compressed Image.gz built successfully!"
          file out/arch/arm64/boot/Image.gz
          BUILD_SUCCESS=true
        elif [ -f "out/vmlinux" ]; then
          echo "✅ vmlinux built successfully!"
          file out/vmlinux
          BUILD_SUCCESS=true
        else
          echo "❌ No kernel output found"
          echo "Checking what was built..."
          find out -name "*.o" -type f | wc -l | xargs echo "Object files:"
          find out -name "built-in.a" -type f | wc -l | xargs echo "Built-in archives:"
        fi
        
        echo "Build success: $BUILD_SUCCESS"
        
    # Step 11: Build modules
    - name: Build Kernel Modules
      if: success() || failure()
      run: |
        cd kernel
        
        echo "=== BUILDING KERNEL MODULES ==="
        
        export ARCH=arm64
        export SUBARCH=arm64
        export CROSS_COMPILE=aarch64-linux-gnu-
        export CROSS_COMPILE_ARM32=arm-linux-gnueabi-
        
        # Check if we should build modules
        if [ -f "out/.config" ] && grep -q "CONFIG_MODULES=y" out/.config; then
          echo "Building modules..."
          make -j${{ env.JOBS }} O=out modules 2>&1 | tee modules.log || {
            echo "Module build had errors..."
            tail -30 modules.log
          }
          
          echo "Modules built. Looking for *.ko files..."
          find out -name "*.ko" -type f | head -10 || echo "No modules found"
        else
          echo "Skipping module build - CONFIG_MODULES not set"
        fi
        
        echo "✅ Module build complete"
        
    # Step 12: Package results
    - name: Package Kernel Output
      if: always()
      run: |
        cd kernel
        
        echo "=== PACKAGING RESULTS ==="
        
        KERNEL_VERSION="${{ steps.check-kernel.outputs.version }}"
        BUILD_DATE=$(date +%Y%m%d-%H%M%S)
        
        echo "1. Creating output directory..."
        mkdir -p kernel_output
        
        echo "2. Collecting any build artifacts..."
        
        # Collect whatever was built
        if [ -f "out/arch/arm64/boot/Image" ]; then
          cp out/arch/arm64/boot/Image kernel_output/
          echo "✅ Copied Image"
        fi
        
        if [ -f "out/arch/arm64/boot/Image.gz" ]; then
          cp out/arch/arm64/boot/Image.gz kernel_output/
          echo "✅ Copied Image.gz"
        fi
        
        if [ -f "out/vmlinux" ]; then
          cp out/vmlinux kernel_output/
          echo "✅ Copied vmlinux"
          # Try to extract binary from vmlinux
          aarch64-linux-gnu-objcopy -O binary -R .note -R .comment -S out/vmlinux kernel_output/vmlinux.bin 2>/dev/null && \
            echo "✅ Created vmlinux.bin"
        fi
        
        echo "3. Collecting any modules..."
        mkdir -p kernel_output/modules
        find out -name "*.ko" -exec cp {} kernel_output/modules/ \; 2>/dev/null | head -5 || echo "No modules to copy"
        
        echo "4. Collecting build logs..."
        mkdir -p kernel_output/logs
        cp build.log kernel_output/logs/ 2>/dev/null || true
        cp modules.log kernel_output/logs/ 2>/dev/null || true
        cp config.log kernel_output/logs/ 2>/dev/null || true
        
        echo "5. Creating build info..."
        {
          echo "=== BUILD REPORT ==="
          echo "Kernel: $KERNEL_VERSION"
          echo "Date: $BUILD_DATE"
          echo "Commit: ${{ github.sha }}"
          echo ""
          echo "=== ARTIFACTS ==="
          ls -la kernel_output/ 2>/dev/null | grep -v "^total" || echo "No artifacts"
          echo ""
          echo "=== CONFIG ==="
          grep -E "SUKISU|MODULES|KPROBES|OVERLAY" out/.config 2>/dev/null || echo "No config"
        } > kernel_output/build_report.txt
        
        echo "6. Final contents:"
        ls -la kernel_output/ || echo "No output directory"
        
        echo "✅ Packaging complete"
        
    # Step 13: Upload artifacts
    - name: Upload Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: kernel-a135f-sukisu-${{ github.sha }}
        path: kernel/kernel_output/
        
    # Step 14: Create summary
    - name: Create Build Summary
      if: always()
      run: |
        echo "## Samsung A135F Kernel Build Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Kernel Version:** \`${{ steps.check-kernel.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Check what was actually built
        echo "**Build Artifacts:**" >> $GITHUB_STEP_SUMMARY
        if [ -f "kernel/kernel_output/Image" ]; then
          echo "- ✅ Kernel Image" >> $GITHUB_STEP_SUMMARY
        elif [ -f "kernel/kernel_output/vmlinux" ]; then
          echo "- ⚠️ vmlinux (needs conversion to Image)" >> $GITHUB_STEP_SUMMARY
        else
          echo "- ❌ No kernel binary" >> $GITHUB_STEP_SUMMARY
        fi
        
        MODULE_COUNT=$(find kernel/kernel_output/modules -name "*.ko" 2>/dev/null | wc -l)
        if [ "$MODULE_COUNT" -gt 0 ]; then
          echo "- ✅ $MODULE_COUNT kernel modules" >> $GITHUB_STEP_SUMMARY
        else
          echo "- ⚠️ No kernel modules" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**SukiSU Status:** Built-in" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Debug:** Check artifact logs for build errors" >> $GITHUB_STEP_SUMMARY
        
    # Step 15: Debug information
    - name: Show Debug Information
      if: always()
      run: |
        cd kernel
        
        echo "=== DEBUG INFORMATION ==="
        echo ""
        echo "1. Build tree structure:"
        find out -maxdepth 2 -type d 2>/dev/null || echo "No out directory"
        
        echo ""
        echo "2. Key build files:"
        ls -la out/arch/arm64/boot/ 2>/dev/null || echo "No boot directory"
        
        echo ""
        echo "3. Critical errors from build log:"
        grep -B5 -A5 "Error " build.log 2>/dev/null | head -30 || echo "No errors in log"
        
        echo ""
        echo "4. First error in build (if any):"
        grep -m1 -i "error:" build.log 2>/dev/null || echo "No error found"
