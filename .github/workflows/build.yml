name: Build Samsung A135F Kernel with SukiSU

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

env:
  KERNEL_NAME: a13x
  ARCH: arm64
  SUBARCH: arm64
  CONFIG: exynos850_defconfig
  TOOLCHAIN_VERSION: gcc-12
  JOBS: 4

jobs:
  build:
    runs-on: ubuntu-22.04
    
    steps:
    - name: Checkout Kernel Source
      uses: actions/checkout@v4
      with:
        path: kernel
        
    - name: Check Kernel Version
      id: check-kernel
      run: |
        cd kernel
        VERSION=$(grep '^VERSION =' Makefile | head -1 | awk '{print $3}')
        PATCHLEVEL=$(grep '^PATCHLEVEL =' Makefile | head -1 | awk '{print $3}')
        SUBLEVEL=$(grep '^SUBLEVEL =' Makefile | head -1 | awk '{print $3}')
        EXTRAVERSION=$(grep '^EXTRAVERSION =' Makefile | head -1 | awk '{print $3}')
        KERNEL_VERSION="${VERSION}.${PATCHLEVEL}.${SUBLEVEL}${EXTRAVERSION}"
        echo "Kernel Version: $KERNEL_VERSION"
        echo "version=$KERNEL_VERSION" >> $GITHUB_OUTPUT
        
    - name: Setup Environment
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          git ccache build-essential zip curl \
          libssl-dev libelf-dev libncurses-dev \
          rsync cpio unzip kmod gcc make flex bison \
          python3 python3-pip bc lz4 lzop xxd wget \
          gcc-aarch64-linux-gnu gcc-arm-linux-gnueabi
        
    - name: Fix Toolchain Issues
      run: |
        cd kernel
        
        echo "Fixing Samsung kernel toolchain issues..."
        
        # 1. Create the expected toolchain directory structure
        mkdir -p toolchain/clang/host/linux-x86/clang-r383902/bin
        
        # 2. Install clang-14 and create symlinks to match expected names
        sudo apt-get install -y clang-14 llvm-14
        
        # 3. Create symlinks for the expected clang toolchain
        ln -sf /usr/bin/clang-14 toolchain/clang/host/linux-x86/clang-r383902/bin/clang
        ln -sf /usr/bin/clang++-14 toolchain/clang/host/linux-x86/clang-r383902/bin/clang++
        
        echo "Created toolchain symlinks"
        
    - name: Fix Script Permissions
      run: |
        cd kernel
        echo "Fixing script permissions..."
        chmod +x scripts/*.sh 2>/dev/null || true
        chmod +x scripts/* 2>/dev/null || true
        find . -name "*.sh" -type f -exec chmod +x {} \; 2>/dev/null || true
        
        # Fix specific problematic scripts
        if [ -f "scripts/gcc-version.sh" ]; then
          echo "Patching gcc-version.sh to use system clang..."
          # Make a backup
          cp scripts/gcc-version.sh scripts/gcc-version.sh.backup
          # Patch to use system clang instead of hardcoded path
          sed -i 's|\.\./toolchain/clang/host/linux-x86/clang-r383902/bin/clang|clang|g' scripts/gcc-version.sh 2>/dev/null || true
        fi
        
        if [ -f "scripts/clang-version.sh" ]; then
          echo "Patching clang-version.sh..."
          cp scripts/clang-version.sh scripts/clang-version.sh.backup
          sed -i 's|\.\./toolchain/clang/host/linux-x86/clang-r383902/bin/clang|clang|g' scripts/clang-version.sh 2>/dev/null || true
        fi
        
    - name: Install SukiSU (Built-in Branch)
      run: |
        cd kernel
        
        echo "Installing SukiSU (builtin branch) using setup script..."
        
        # Remove any previous KernelSU/SukiSU attempts
        rm -rf KernelSU SukiSU kernelsu
        
        # Use the official setup script for SukiSU-Ultra
        curl -LSs 'https://raw.githubusercontent.com/SukiSU-Ultra/SukiSU-Ultra/main/kernel/setup.sh' | bash -s builtin
        
        # Check if the setup script created what we need
        echo "Checking created files..."
        if [ -L "KernelSU" ] || [ -d "KernelSU" ]; then
          echo "✅ SukiSU setup script completed successfully"
        else
          echo "⚠️ Setup script may not have created expected structure"
          echo "Current directory contents:"
          ls -la | grep -i suki || ls -la | grep -i kernelsu || echo "No SukiSU/KernelSU files visible"
        fi
        
    - name: Patch Makefile for GCC Build
      run: |
        cd kernel
        
        echo "Patching Makefile to use GCC instead of missing Clang..."
        
        # Create backup of original Makefile
        cp Makefile Makefile.backup
        
        # Patch to use GCC for host builds
        sed -i 's|HOSTCC\t= \$(CROSS_COMPILE)gcc|HOSTCC\t= gcc|g' Makefile 2>/dev/null || true
        sed -i 's|HOSTCXX\t= \$(CROSS_COMPILE)g++|HOSTCXX\t= g++|g' Makefile 2>/dev/null || true
        
        # Check if there are hardcoded clang paths in the Makefile
        if grep -q "clang-r383902" Makefile; then
          echo "Found hardcoded clang-r383902 paths, patching..."
          sed -i 's|\.\./toolchain/clang/host/linux-x86/clang-r383902/bin/clang|gcc|g' Makefile 2>/dev/null || true
        fi
        
        echo "Makefile patched for GCC build"
        
    - name: Configure Kernel with SukiSU
      run: |
        cd kernel
        
        export ARCH=arm64
        export SUBARCH=arm64
        export CROSS_COMPILE=aarch64-linux-gnu-
        export CROSS_COMPILE_ARM32=arm-linux-gnueabi-
        
        # Set host compiler to GCC explicitly
        export HOSTCC=gcc
        export HOSTCXX=g++
        
        echo "Using host compiler: $(which gcc)"
        
        # Create output directory
        mkdir -p out
        
        echo "Generating base configuration with GCC..."
        
        # Generate config with GCC
        make O=out exynos850_defconfig HOSTCC=gcc HOSTCXX=g++
        
        echo "Configuring for SukiSU (built-in module)..."
        
        # Add SukiSU configuration
        echo "CONFIG_KPROBES=y" >> out/.config
        echo "CONFIG_HAVE_KPROBES=y" >> out/.config
        echo "CONFIG_KPROBE_EVENTS=y" >> out/.config
        echo "CONFIG_OVERLAY_FS=y" >> out/.config
        echo "CONFIG_MODULES=y" >> out/.config
        echo "CONFIG_MODULE_UNLOAD=y" >> out/.config
        echo "CONFIG_SUKISU=y" >> out/.config
        echo "CONFIG_SUKISU_BUILTIN=y" >> out/.config
        
        # Update configuration
        make O=out olddefconfig HOSTCC=gcc HOSTCXX=g++
        
        echo "Kernel configuration complete."
        echo "Relevant configs:"
        grep -E "CONFIG_SUKISU|CONFIG_MODULES|CONFIG_KPROBES" out/.config || true
        
    - name: Build Kernel
      run: |
        cd kernel
        
        export ARCH=arm64
        export SUBARCH=arm64
        export CROSS_COMPILE=aarch64-linux-gnu-
        export CROSS_COMPILE_ARM32=arm-linux-gnueabi-
        export HOSTCC=gcc
        export HOSTCXX=g++
        
        echo "Starting kernel build with GCC..."
        echo "Using host compiler: $(which gcc)"
        echo "Using cross compiler: $(which aarch64-linux-gnu-gcc)"
        
        # Build with verbose output to see any errors
        make -j${{ env.JOBS }} O=out V=1 2>&1 | tee build.log || {
          echo "Build failed, showing last 100 lines:"
          tail -100 build.log
          exit 1
        }
        
        echo "Kernel build completed!"
        
        # Check for output
        ls -la out/arch/arm64/boot/ 2>/dev/null || echo "Checking for output files..."
        
    - name: Build Modules
      run: |
        cd kernel
        
        export ARCH=arm64
        export SUBARCH=arm64
        export CROSS_COMPILE=aarch64-linux-gnu-
        export CROSS_COMPILE_ARM32=arm-linux-gnueabi-
        
        echo "Building modules..."
        make -j${{ env.JOBS }} O=out modules 2>&1 | tee modules.log
        
    - name: Verify Build
      run: |
        cd kernel
        
        echo "Verifying build output..."
        
        if [ -f "out/arch/arm64/boot/Image" ]; then
          echo "✅ Kernel Image found: out/arch/arm64/boot/Image"
          file out/arch/arm64/boot/Image
        elif [ -f "out/arch/arm64/boot/Image.gz" ]; then
          echo "✅ Compressed Kernel Image found: out/arch/arm64/boot/Image.gz"
        else
          echo "❌ No kernel image found!"
          echo "Generated files in out/arch/arm64/boot/:"
          ls -la out/arch/arm64/boot/ 2>/dev/null || echo "Directory not found"
        fi
        
    - name: Package Kernel
      run: |
        cd kernel
        
        KERNEL_VERSION="${{ steps.check-kernel.outputs.version }}"
        mkdir -p kernel_output
        
        # Copy kernel image
        if [ -f "out/arch/arm64/boot/Image" ]; then
          cp out/arch/arm64/boot/Image kernel_output/
          echo "✅ Copied kernel Image"
        elif [ -f "out/arch/arm64/boot/Image.gz" ]; then
          cp out/arch/arm64/boot/Image.gz kernel_output/
          echo "✅ Copied compressed kernel Image"
        fi
        
        # Copy modules
        mkdir -p kernel_output/modules
        find out -name "*.ko" -exec cp {} kernel_output/modules/ \; 2>/dev/null || true
        
        echo "Package created in kernel_output/"
        ls -la kernel_output/
        
    - name: Upload Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: kernel-a135f-${{ github.sha }}
        path: kernel/kernel_output/
